# Build Your First Chaos Plugin with Krkn

## Overview

Krkn allows contributors to extend its chaos testing capabilities by writing custom plugins. This guide walks you through building your first plugin using a reusable boilerplate template.

## Prerequisites

- Python 3.8+
- Familiarity with Kubernetes concepts (pods, services)
- Basic understanding of Python classes
- Knowledge of the specific chaos scenario you want to implement

## Plugin Architecture

Krkn plugins follow this structure:

- `__init__`: Initializes plugin with config
- `run()`: Contains the chaos injection logic
- `get_scenario_types()`: Specifies which scenario types this plugin handles
- `metadata()`: Plugin details (name, description, etc.)
- `parameters()`: Acceptable parameters for your plugin

Each plugin must extend the `AbstractScenarioPlugin` abstract class and implement its required methods.

## Step-by-Step: Writing Your Plugin

1. Navigate to `krkn/tests/test_classes/`
2. Copy `example_scenario_plugin.py` to your desired location within the Krkn plugin directory structure (`krkn/scenario_plugins/`)
3. Rename your plugin following the naming convention: `your_scenario_plugin.py`
4. Implement the required methods, focusing on the `run()` method which contains your chaos injection logic

## Example Code

```python
from krkn_lib.models.telemetry import ScenarioTelemetry
from krkn_lib.telemetry.ocp import KrknTelemetryOpenshift
from krkn.scenario_plugins.abstract_scenario_plugin import AbstractScenarioPlugin

class MyCustomPlugin(AbstractScenarioPlugin):
    
    def run(
        self,
        run_uuid: str,
        scenario: str,
        krkn_config: dict[str, any],
        lib_telemetry: KrknTelemetryOpenshift,
        scenario_telemetry: ScenarioTelemetry,
    ) -> int:
        """
        Implementation of chaos scenario logic
        
        :param run_uuid: the uuid of the chaos run generated by krkn
        :param scenario: the config file of the scenario being executed
        :param krkn_config: the full dictionary representation of `config.yaml`
        :param lib_telemetry: composite object of krkn-lib objects and methods
        :param scenario_telemetry: the ScenarioTelemetry object for the current scenario
        :return: 0 for success, 1 for failure
        """
        
        try:
            # Access Kubernetes primitives
            krkn_kubernetes = lib_telemetry.get_lib_kubernetes()
            
            # For OpenShift-specific functionality
            krkn_openshift = lib_telemetry.get_lib_ocp()
            
            # Example: Delete pods in a specific namespace
            namespace = "my-target-namespace"
            krkn_kubernetes.delete_pods(namespace=namespace)
            
            # Add your custom chaos logic here
            
            # Return 0 for success
            return 0
            
        except Exception as e:
            # Log the exception
            print(f"Error in chaos scenario: {str(e)}")
            # Return 1 for failure
            return 1
    
    def get_scenario_types(self) -> list[str]:
        """
        Returns the scenario types that this plugin handles
        Must match scenario_type in config.yaml
        """
        return ["my_custom_scenario"]
```

## Plugin Configuration

Your plugin needs to be configured in the `config.yaml` file:

```yaml
chaos_scenarios:
  - name: my-custom-chaos
    scenario_type: my_custom_scenario
    # Additional configuration specific to your plugin
    namespace: my-target-namespace
    duration: 300
```

## Testing Your Plugin

You can test your plugin with pytest:

```bash
pytest krkn/tests/
```

Or run it directly with Krkn:

```bash
python3 run_kraken.py --config=config.yaml
```

## Best Practices

1. **Use logging over print statements**
   - Use the logging framework for consistent output

2. **Handle exceptions properly**
   - Catch and log all exceptions within your plugin
   - Return appropriate status codes (0 for success, 1 for failure)

3. **Keep configuration external**
   - Use the config.yaml for all configurable parameters
   - Don't hardcode values in your plugin

4. **Add meaningful documentation**
   - Add docstrings to your methods
   - Explain what your chaos scenario does

5. **Follow naming conventions**
   - Name your plugin file and class consistently
   - Use descriptive names that reflect the chaos scenario

## Plugin Directory Structure

```
krkn/
├── scenario_plugins/
│   ├── my_scenario_plugin/
│   │   ├── __init__.py
│   │   └── my_scenario_plugin.py
```

## Conclusion

Congratulations! You've created your first Krkn chaos plugin. By following this guide, you can extend Krkn's capabilities with your own custom chaos scenarios, helping to improve the resilience of Kubernetes applications.

For more details, refer to the [Scenario Plugin API documentation](https://krkn-chaos.dev/docs/contribution-guidelines/scenario_plugin_api/) and the [example plugin](https://github.com/krkn-chaos/krkn/blob/main/krkn/tests/test_classes/example_scenario_plugin.py).
